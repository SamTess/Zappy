"use strict";(self.webpackChunkdocs_docusaurus=self.webpackChunkdocs_docusaurus||[]).push([[9623],{1797:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>s,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"gui/gui-overview","title":"Graphical Interface Architecture","description":"Overview","source":"@site/docs/gui/gui-overview.md","sourceDirName":"gui","slug":"/gui/gui-overview","permalink":"/Zappy/en/docs/gui/gui-overview","draft":false,"unlisted":false,"editUrl":"https://github.com/Epitech/Zappy/tree/main/docs/docusaurus/docs/gui/gui-overview.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Server Architecture and Implementation","permalink":"/Zappy/en/docs/server/server-overview"},"next":{"title":"AI Client Architecture","permalink":"/Zappy/en/docs/ai/ai-overview"}}');var a=t(4848),i=t(8453);const s={sidebar_position:1},o="Graphical Interface Architecture",l={},d=[{value:"Overview",id:"overview",level:2},{value:"Core Architecture",id:"core-architecture",level:2},{value:"Main Components",id:"main-components",level:3},{value:"Dynamic Library System",id:"dynamic-library-system",level:2},{value:"Library Interfaces",id:"library-interfaces",level:3},{value:"Library Manager",id:"library-manager",level:3},{value:"Rendering System",id:"rendering-system",level:2},{value:"Camera Control System",id:"camera-control-system",level:2},{value:"Network Communication",id:"network-communication",level:2},{value:"Texture and Model Management",id:"texture-and-model-management",level:2},{value:"User Interface Components",id:"user-interface-components",level:2},{value:"Performance Optimizations",id:"performance-optimizations",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"graphical-interface-architecture",children:"Graphical Interface Architecture"})}),"\n",(0,a.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(n.p,{children:"The Zappy graphical interface is developed in C++ leveraging Raylib for 3D rendering. It provides a real-time visualization of the game state through a sophisticated, modular architecture built on dynamic library loading and component-based design."}),"\n",(0,a.jsx)(n.h2,{id:"core-architecture",children:"Core Architecture"}),"\n",(0,a.jsx)(n.h3,{id:"main-components",children:"Main Components"}),"\n",(0,a.jsx)(n.p,{children:"The GUI is structured around a central game loop that integrates multiple specialized components:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"class GameLoop : public IGraphicalContextObserver {\nprivate:\n    // Core systems\n    std::shared_ptr<IGraphicsLib> m_graphics;      // Graphics abstraction (Raylib)\n    std::shared_ptr<IGuiLib> m_gui;                // UI framework interface\n    GraphicalContext m_context;                    // Game state context\n    std::unique_ptr<Renderer> m_renderer;          // 3D rendering pipeline\n    std::unique_ptr<CameraController> m_camera;    // Camera management\n    std::unique_ptr<NetworkManager> m_network;     // Server communication\n    \n    // State management\n    GameState m_currentState;                      // Cached game state\n    std::atomic<bool> m_running;                   // Main loop control\n    \npublic:\n    void run() override;\n    void onStateUpdate(const GameState& state) override;\n    void handleEvent(const Event& event) override;\n    \nprivate:\n    void processNetworkEvents();\n    void updateSystems(float deltaTime);\n    void renderFrame();\n    void handleInput();\n};\n"})}),"\n",(0,a.jsx)(n.h2,{id:"dynamic-library-system",children:"Dynamic Library System"}),"\n",(0,a.jsx)(n.p,{children:"The GUI uses an advanced dynamic library loading system that enables modular development and component replacement without recompilation."}),"\n",(0,a.jsx)(n.h3,{id:"library-interfaces",children:"Library Interfaces"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"// Abstract graphics interface\nclass IGraphicsLib {\npublic:\n    virtual ~IGraphicsLib() = default;\n    \n    // Core functions\n    virtual bool init(int width, int height, const std::string& title) = 0;\n    virtual void beginDrawing() = 0;\n    virtual void endDrawing() = 0;\n    virtual void clearBackground(ZappyTypes::Color color) = 0;\n    virtual bool windowShouldClose() = 0;\n    \n    // Camera operations\n    virtual void setCameraMode(ZappyTypes::Camera camera, int mode) = 0;\n    virtual void updateCamera(ZappyTypes::Camera* camera) = 0;\n    virtual void setCameraPosition(ZappyTypes::Camera* camera, ZappyTypes::Vector3 position) = 0;\n    \n    // Shape rendering\n    virtual void drawCube(ZappyTypes::Vector3 position, float width, float height, float length, ZappyTypes::Color color) = 0;\n    virtual void drawModel(ZappyTypes::Model model, ZappyTypes::Vector3 position, float scale, ZappyTypes::Color tint) = 0;\n    virtual void drawText3D(const std::string& text, ZappyTypes::Vector3 position, float fontSize, ZappyTypes::Color color) = 0;\n    \n    // 2D UI rendering\n    virtual void drawRectangle(int x, int y, int width, int height, ZappyTypes::Color color) = 0;\n    virtual void drawText(const std::string& text, int x, int y, int fontSize, ZappyTypes::Color color) = 0;\n    \n    // Resource loading\n    virtual ZappyTypes::Model loadModel(const std::string& filename) = 0;\n    virtual ZappyTypes::Texture2D loadTexture(const std::string& filename) = 0;\n    virtual void unloadModel(ZappyTypes::Model model) = 0;\n    virtual void unloadTexture(ZappyTypes::Texture2D texture) = 0;\n};\n\n// Abstract GUI interface\nclass IGuiLib {\npublic:\n    virtual ~IGuiLib() = default;\n    \n    // UI components\n    virtual bool button(ZappyTypes::Rectangle bounds, const std::string& text) = 0;\n    virtual bool checkbox(ZappyTypes::Rectangle bounds, const std::string& text, bool& checked) = 0;\n    virtual bool slider(ZappyTypes::Rectangle bounds, const std::string& text, float& value, float min, float max) = 0;\n    virtual bool dropdownBox(ZappyTypes::Rectangle bounds, const std::vector<std::string>& items, int& active) = 0;\n    \n    // Windows and panels\n    virtual bool windowBox(ZappyTypes::Rectangle bounds, const std::string& title) = 0;\n    virtual bool groupBox(ZappyTypes::Rectangle bounds, const std::string& text) = 0;\n    virtual bool panel(ZappyTypes::Rectangle bounds) = 0;\n    \n    // Text controls\n    virtual void label(ZappyTypes::Rectangle bounds, const std::string& text) = 0;\n    virtual bool textBox(ZappyTypes::Rectangle bounds, std::string& text, int maxLength, bool editMode) = 0;\n    \n    // Visuals\n    virtual void statusBar(ZappyTypes::Rectangle bounds, const std::string& text) = 0;\n    virtual void progressBar(ZappyTypes::Rectangle bounds, const std::string& text, float value, float min, float max) = 0;\n};\n"})}),"\n",(0,a.jsx)(n.h3,{id:"library-manager",children:"Library Manager"}),"\n",(0,a.jsx)(n.p,{children:"The GUI implements a powerful library manager that handles dynamic library loading and interfaces:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:'class LibraryManager {\nprivate:\n    std::unordered_map<std::string, void*> m_loadedLibraries;\n    std::mutex m_libraryMutex;\n    \npublic:\n    // Singleton pattern\n    static LibraryManager& getInstance() {\n        static LibraryManager instance;\n        return instance;\n    }\n    \n    template<typename T>\n    std::shared_ptr<T> getInterface(const std::string& libraryPath, const std::string& factoryFunction) {\n        std::lock_guard<std::mutex> lock(m_libraryMutex);\n        \n        void* handle = loadLibrary(libraryPath);\n        if (!handle) {\n            std::cerr << "Failed to load library: " << libraryPath << std::endl;\n            return nullptr;\n        }\n        \n        // Get factory function from library\n        typedef T* (*CreateInstanceFunc)();\n        CreateInstanceFunc createFunc = (CreateInstanceFunc)dlsym(handle, factoryFunction.c_str());\n        \n        if (!createFunc) {\n            std::cerr << "Failed to find factory function: " << factoryFunction << std::endl;\n            return nullptr;\n        }\n        \n        // Create interface instance with custom deleter\n        return std::shared_ptr<T>(createFunc(), \n            [this, libraryPath](T* ptr) {\n                delete ptr;\n                unloadLibrary(libraryPath);\n            });\n    }\n    \nprivate:\n    LibraryManager() = default;\n    void* loadLibrary(const std::string& path);\n    void unloadLibrary(const std::string& path);\n};\n'})}),"\n",(0,a.jsx)(n.h2,{id:"rendering-system",children:"Rendering System"}),"\n",(0,a.jsx)(n.p,{children:"The rendering system uses the Strategy pattern to support multiple visualization techniques:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"// Tile rendering strategy interface\nclass ITileRenderStrategy {\npublic:\n    virtual ~ITileRenderStrategy() = default;\n    virtual void renderTile(const std::shared_ptr<IGraphicsLib>& graphicsLib,\n        int x, int y,\n        const ZappyTypes::Color& color,\n        float tileSize,\n        float spacing) = 0;\n};\n\n// Implementation strategies\nclass SimpleTileRenderStrategy : public ITileRenderStrategy {\n    // Simple flat tile rendering\n};\n\nclass DetailedTileRenderStrategy : public ITileRenderStrategy {\n    // Enhanced tile with resource visualization\n};\n\nclass ModelTileRenderStrategy : public ITileRenderStrategy {\n    // 3D model-based tile rendering\n};\n\n// Factory for creating tile rendering strategies\nclass TileRenderStrategyFactory {\npublic:\n    static std::unique_ptr<ITileRenderStrategy> createStrategy(\n        TileRenderStrategyType type,\n        const std::shared_ptr<GraphicalContext>& context) {\n        \n        switch (type) {\n            case TileRenderStrategyType::SIMPLE:\n                return std::make_unique<SimpleTileRenderStrategy>();\n            case TileRenderStrategyType::DETAILED:\n                return std::make_unique<DetailedTileRenderStrategy>(context);\n            case TileRenderStrategyType::MODEL:\n                return std::make_unique<ModelTileRenderStrategy>(context);\n            default:\n                return std::make_unique<SimpleTileRenderStrategy>();\n        }\n    }\n};\n"})}),"\n",(0,a.jsx)(n.h2,{id:"camera-control-system",children:"Camera Control System"}),"\n",(0,a.jsx)(n.p,{children:"The camera system provides multiple viewing modes and smooth transitions:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"class CameraController {\nprivate:\n    std::shared_ptr<IGraphicsLib> m_graphicsLib;\n    ZappyTypes::Camera m_camera;\n    CameraMode m_currentMode;\n    \n    // Animation parameters\n    ZappyTypes::Vector3 m_targetPosition;\n    ZappyTypes::Vector3 m_targetTarget;\n    float m_transitionSpeed;\n    bool m_inTransition;\n\npublic:\n    CameraController(std::shared_ptr<IGraphicsLib> graphicsLib);\n    \n    // Camera modes\n    void setOverheadView();\n    void setIsometricView();\n    void setFollowPlayerView(int playerId);\n    void setFreeView();\n    \n    // Camera operations\n    void update(float deltaTime);\n    void handleInput(const InputState& input);\n    void zoomIn(float factor);\n    void zoomOut(float factor);\n    void rotateLeft(float angle);\n    void rotateRight(float angle);\n    \n    // Transitions\n    void transitionTo(const ZappyTypes::Vector3& position, const ZappyTypes::Vector3& target, float duration);\n};\n"})}),"\n",(0,a.jsx)(n.h2,{id:"network-communication",children:"Network Communication"}),"\n",(0,a.jsx)(n.p,{children:"The network component manages bidirectional communication with the server:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"class NetworkManager {\nprivate:\n    std::string m_host;\n    int m_port;\n    int m_socket;\n    std::atomic<bool> m_connected;\n    \n    std::thread m_receiveThread;\n    std::mutex m_queueMutex;\n    std::queue<std::string> m_messageQueue;\n    \n    GameState* m_gameState;\n\npublic:\n    NetworkManager(const std::string& host, int port, GameState* gameState);\n    ~NetworkManager();\n    \n    // Connection management\n    bool connect();\n    void disconnect();\n    bool isConnected() const;\n    \n    // Communication\n    bool sendCommand(const std::string& command);\n    std::optional<std::string> getNextMessage();\n    \n    // Protocol handling\n    void processServerUpdates();\n    void parseMapSizeMessage(const std::string& message);\n    void parseTileContentMessage(const std::string& message);\n    void parsePlayerMessage(const std::string& message);\n    \nprivate:\n    void receiveThreadFunction();\n    void updateGameState(const std::string& message);\n};\n"})}),"\n",(0,a.jsx)(n.h2,{id:"texture-and-model-management",children:"Texture and Model Management"}),"\n",(0,a.jsx)(n.p,{children:"Resource management is handled through a specialized system:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"class TextureManager {\nprivate:\n    std::shared_ptr<IGraphicsLib> m_graphicsLib;\n    std::unordered_map<std::string, ZappyTypes::Texture2D> m_textures;\n    std::unordered_map<std::string, ZappyTypes::Model> m_models;\n\npublic:\n    explicit TextureManager(std::shared_ptr<IGraphicsLib> graphicsLib);\n    ~TextureManager();\n    \n    // Resource loading\n    ZappyTypes::Texture2D loadTexture(const std::string& path);\n    ZappyTypes::Model loadModel(const std::string& path);\n    \n    // Resource access\n    ZappyTypes::Texture2D getTexture(const std::string& name);\n    ZappyTypes::Model getModel(const std::string& name);\n    \n    // Resource unloading\n    void unloadAll();\n};\n"})}),"\n",(0,a.jsx)(n.h2,{id:"user-interface-components",children:"User Interface Components"}),"\n",(0,a.jsx)(n.p,{children:"The UI system includes specialized components for game state visualization:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"class TeamPanel {\npublic:\n    void render(const std::shared_ptr<IGuiLib>& guiLib, const GameState& gameState);\n};\n\nclass PlayerInfoPanel {\npublic:\n    void render(const std::shared_ptr<IGuiLib>& guiLib, const Player& player);\n};\n\nclass MapControlPanel {\npublic:\n    void render(const std::shared_ptr<IGuiLib>& guiLib, CameraController& cameraController);\n};\n\nclass TimeControlPanel {\npublic:\n    void render(const std::shared_ptr<IGuiLib>& guiLib, NetworkManager& networkManager);\n};\n"})}),"\n",(0,a.jsx)(n.h2,{id:"performance-optimizations",children:"Performance Optimizations"}),"\n",(0,a.jsx)(n.p,{children:"The GUI implements several optimizations for smooth performance:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Frustum Culling"}),": Only renders tiles within the camera view"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Level of Detail (LOD)"}),": Adjusts rendering detail based on camera distance"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Texture Atlasing"}),": Combines multiple textures to reduce draw calls"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Instanced Rendering"}),": Efficiently renders multiple identical objects"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Asynchronous Resource Loading"}),": Loads textures and models in background threads"]}),"\n"]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsxs)(n.p,{children:["This document provides a technical overview of the GUI architecture. For implementation details, refer to the source code in ",(0,a.jsx)(n.code,{children:"src/GUI/"})," directory."]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}}}]);