"use strict";(self.webpackChunkdocs_docusaurus=self.webpackChunkdocs_docusaurus||[]).push([[9741],{2682:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"ai/ai-overview","title":"AI Client Architecture","description":"Overview","source":"@site/docs/ai/ai-overview.md","sourceDirName":"ai","slug":"/ai/ai-overview","permalink":"/Zappy/en/docs/ai/ai-overview","draft":false,"unlisted":false,"editUrl":"https://github.com/Epitech/Zappy/tree/main/docs/docusaurus/docs/ai/ai-overview.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Graphical Interface Architecture","permalink":"/Zappy/en/docs/gui/gui-overview"},"next":{"title":"Server-AI Protocol","permalink":"/Zappy/en/docs/protocols/server-ai"}}');var s=t(4848),i=t(8453);const a={sidebar_position:1},o="AI Client Architecture",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Agent Architecture",id:"agent-architecture",level:2},{value:"Core Structure",id:"core-structure",level:3},{value:"Behavior System",id:"behavior-system",level:2},{value:"Decision Making Engine",id:"decision-making-engine",level:3},{value:"Comportement Dyson (Collecte optimis\xe9e)",id:"comportement-dyson-collecte-optimis\xe9e",level:3},{value:"Comportement Incanter (\xc9volution)",id:"comportement-incanter-\xe9volution",level:3},{value:"Communication Inter-Agents",id:"communication-inter-agents",level:2},{value:"Gestionnaire de broadcast",id:"gestionnaire-de-broadcast",level:3},{value:"Pathfinding System",id:"pathfinding-system",level:2},{value:"Level-Specific Strategies",id:"level-specific-strategies",level:2},{value:"State Machine Implementation",id:"state-machine-implementation",level:2},{value:"Resource Requirements by Level",id:"resource-requirements-by-level",level:2},{value:"Performance Optimization",id:"performance-optimization",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"ai-client-architecture",children:"AI Client Architecture"})}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"The Zappy AI client is developed in Python with a modular architecture that enables adaptive behaviors and secure communication between agents. This section provides a detailed technical overview of the AI system architecture."}),"\n",(0,s.jsx)(n.h2,{id:"agent-architecture",children:"Agent Architecture"}),"\n",(0,s.jsx)(n.h3,{id:"core-structure",children:"Core Structure"}),"\n",(0,s.jsxs)(n.p,{children:["The AI system is built around a central ",(0,s.jsx)(n.code,{children:"Agent"})," class that manages all aspects of an AI player's behavior:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class Agent:\n    def __init__(self, ip, port, team, agent_id=0):\n        self.ip = ip\n        self.port = port\n        self.level = 1\n        self.team = team\n        self.id = agent_id\n        self.map_size_x = None\n        self.map_size_y = None\n        self.current_behaviour = "Dyson"\n        \n        # Core managers\n        self.decisionManager = DecisionManager(self)\n        self.broadcastManager = BroadcastManager(self)\n        self.socketManager = SocketManager(self.sock)\n        self.logger = Logger("AI.log", message_prefix=f"(Agent #{self.id}): ")\n'})}),"\n",(0,s.jsx)(n.h2,{id:"behavior-system",children:"Behavior System"}),"\n",(0,s.jsx)(n.h3,{id:"decision-making-engine",children:"Decision Making Engine"}),"\n",(0,s.jsx)(n.p,{children:"The decision-making system uses a sophisticated behavior selection algorithm:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class DecisionManager:\n    def __init__(self, agent):\n        self.agent = agent\n        self.behaviors = {\n            "Dyson": DysonBehavior(),       # Efficient resource collection\n            "Explorer": ExplorerBehavior(),  # Map exploration\n            "Incanter": IncanterBehavior(),  # Ritual performer\n            "Breeder": BreederBehavior(),    # Reproduction (fork)\n            "Helper": HelperBehavior()       # Assistance to other agents\n        }\n        self.current_behavior = None\n        \n    def decide_behavior(self):\n        """Selects behavior based on current state"""\n        agent_state = self.analyze_agent_state()\n        \n        # Survival is the highest priority\n        if agent_state.food_level < 10:\n            return self.behaviors["Dyson"]\n        # Level up when conditions are met\n        elif agent_state.can_level_up:\n            return self.behaviors["Incanter"]\n        # Explore when needed\n        elif agent_state.exploration_needed:\n            return self.behaviors["Explorer"]\n        # Default to resource collection\n        else:\n            return self.behaviors["Dyson"]\n    \n    def execute_behavior(self):\n        """Ex\xe9cution du comportement s\xe9lectionn\xe9"""\n        behavior = self.decide_behavior()\n        \n        if behavior != self.current_behavior:\n            self.agent.logger.log(f"Switching to behavior: {behavior.__class__.__name__}")\n            self.current_behavior = behavior\n            \n        action = behavior.get_next_action(self.agent)\n        if action:\n            self.agent.execute_action(action)\n'})}),"\n",(0,s.jsx)(n.h3,{id:"comportement-dyson-collecte-optimis\xe9e",children:"Comportement Dyson (Collecte optimis\xe9e)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"class DysonBehavior(IBehavior):\n    def __init__(self):\n        self.target_resource = None\n        self.path_to_target = []\n        self.exploration_pattern = SpiralPattern()\n        \n    def get_next_action(self, agent):\n        # Analyse de l'environnement local\n        environment = agent.look()\n        \n        # Recherche de ressources \xe0 proximit\xe9\n        local_resources = self.analyze_resources(environment)\n        \n        if local_resources:\n            return self.collect_nearest_resource(local_resources)\n        \n        # Si pas de ressources locales, explorer\n        if not self.target_resource:\n            self.target_resource = self.find_target_resource(agent)\n            \n        if self.target_resource:\n            return self.move_towards_target(agent)\n        else:\n            return self.exploration_pattern.get_next_move(agent)\n    \n    def analyze_resources(self, environment):\n        \"\"\"Analyse les ressources dans l'environnement visible\"\"\"\n        resources = []\n        for i, tile in enumerate(environment):\n            for item in tile:\n                if item in ['food', 'linemate', 'deraumere', 'sibur', \n                           'mendiane', 'phiras', 'thystame']:\n                    resources.append({\n                        'type': item,\n                        'distance': self.calculate_distance_from_index(i),\n                        'priority': self.get_resource_priority(item)\n                    })\n        \n        # Tri par priorit\xe9 et distance\n        return sorted(resources, key=lambda x: (x['priority'], x['distance']))\n    \n    def get_resource_priority(self, resource):\n        \"\"\"Priorit\xe9 des ressources selon les besoins actuels\"\"\"\n        priority_map = {\n            'food': 1,      # Priorit\xe9 maximale pour la survie\n            'linemate': 2,  # N\xe9cessaire pour toutes les \xe9l\xe9vations\n            'deraumere': 3,\n            'sibur': 3,\n            'mendiane': 4,\n            'phiras': 4,\n            'thystame': 5   # Rare et pour hauts niveaux seulement\n        }\n        return priority_map.get(resource, 10)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"comportement-incanter-\xe9volution",children:"Comportement Incanter (\xc9volution)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"class IncanterBehavior(IBehavior):\n    def __init__(self):\n        self.elevation_requirements = {\n            1: {'players': 1, 'linemate': 1},\n            2: {'players': 2, 'linemate': 1, 'deraumere': 1, 'sibur': 1},\n            3: {'players': 2, 'linemate': 2, 'sibur': 1, 'phiras': 2},\n            4: {'players': 4, 'linemate': 1, 'deraumere': 1, 'sibur': 2, 'phiras': 1},\n            5: {'players': 4, 'linemate': 1, 'deraumere': 2, 'sibur': 1, 'mendiane': 3},\n            6: {'players': 6, 'linemate': 1, 'deraumere': 2, 'sibur': 3, 'phiras': 1},\n            7: {'players': 6, 'linemate': 2, 'deraumere': 2, 'sibur': 2, \n                'mendiane': 2, 'phiras': 2, 'thystame': 1}\n        }\n        \n    def get_next_action(self, agent):\n        current_level = agent.level\n        requirements = self.elevation_requirements.get(current_level)\n        \n        if not requirements:\n            return None  # Niveau maximum atteint\n        \n        # V\xe9rification des ressources n\xe9cessaires\n        inventory = agent.get_inventory()\n        missing_resources = self.check_missing_resources(inventory, requirements)\n        \n        if missing_resources:\n            # Collecter les ressources manquantes\n            return CollectResourceAction(missing_resources[0])\n        \n        # V\xe9rification du nombre de joueurs\n        players_on_tile = self.count_players_on_tile(agent)\n        required_players = requirements['players']\n        \n        if players_on_tile < required_players:\n            # Appeler d'autres joueurs de l'\xe9quipe\n            return BroadcastAction(f\"INCANTATION_CALL:{agent.x},{agent.y}\")\n        \n        # Toutes les conditions remplies, lancer l'incantation\n        return IncantationAction()\n    \n    def check_missing_resources(self, inventory, requirements):\n        \"\"\"Retourne la liste des ressources manquantes\"\"\"\n        missing = []\n        for resource, needed in requirements.items():\n            if resource == 'players':\n                continue\n            current = inventory.get(resource, 0)\n            if current < needed:\n                missing.extend([resource] * (needed - current))\n        return missing\n"})}),"\n",(0,s.jsx)(n.h2,{id:"communication-inter-agents",children:"Communication Inter-Agents"}),"\n",(0,s.jsx)(n.h3,{id:"gestionnaire-de-broadcast",children:"Gestionnaire de broadcast"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class BroadcastManager:\n    def __init__(self, agent):\n        self.agent = agent\n        self.message_queue = asyncio.Queue()\n        self.team_key = self.generate_team_key(agent.team)\n        self.message_types = {\n            "RESOURCE": 1,\n            "INCANTATION": 2,\n            "DANGER": 3,\n            "POSITION": 4,\n            "REQUEST": 5\n        }\n    \n    def generate_team_key(self, team_name):\n        """Create encryption key from team name"""\n        return hashlib.sha256(team_name.encode()).digest()[:16]\n    \n    def encrypt_message(self, message):\n        """Encrypt message for team-only communication"""\n        cipher = AES.new(self.team_key, AES.MODE_CFB, iv=b\'0123456789abcdef\')\n        return base64.b64encode(cipher.encrypt(message.encode())).decode()\n    \n    def decrypt_message(self, encrypted_message):\n        """Decrypt message from team member"""\n        try:\n            cipher = AES.new(self.team_key, AES.MODE_CFB, iv=b\'0123456789abcdef\')\n            message = base64.b64decode(encrypted_message)\n            return cipher.decrypt(message).decode()\n        except:\n            return None  # Message from another team or invalid\n'})}),"\n",(0,s.jsx)(n.h2,{id:"pathfinding-system",children:"Pathfinding System"}),"\n",(0,s.jsx)(n.p,{children:"Movement planning uses a sophisticated A* algorithm adapted for the toroidal game world:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class AStarPathfinder:\n    def __init__(self, world_map):\n        self.world_map = world_map\n        \n    def find_path(self, start, goal):\n        """Find optimal path using A* algorithm"""\n        # Initialize open and closed sets\n        open_set = PriorityQueue()\n        open_set.put((0, start))\n        came_from = {start: None}\n        cost_so_far = {start: 0}\n        \n        while not open_set.empty():\n            _, current = open_set.get()\n            \n            if current == goal:\n                return self.reconstruct_path(came_from, start, goal)\n            \n            for neighbor in self.get_neighbors(current):\n                # Calculate new cost\n                new_cost = cost_so_far[current] + 1\n                \n                if neighbor not in cost_so_far or new_cost < cost_so_far[neighbor]:\n                    # Update path info\n                    cost_so_far[neighbor] = new_cost\n                    priority = new_cost + self.toroidal_heuristic(neighbor, goal)\n                    open_set.put((priority, neighbor))\n                    came_from[neighbor] = current\n        \n        return []  # No path found\n    \n    def toroidal_heuristic(self, point1, point2):\n        """Calculate Manhattan distance on a toroidal map"""\n        dx = min(abs(point2.x - point1.x), \n                 self.world_map.width - abs(point2.x - point1.x))\n        dy = min(abs(point2.y - point1.y),\n                 self.world_map.height - abs(point2.y - point1.y))\n        return dx + dy\n'})}),"\n",(0,s.jsx)(n.h2,{id:"level-specific-strategies",children:"Level-Specific Strategies"}),"\n",(0,s.jsx)(n.p,{children:"The AI implements different strategies based on the player's level:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Level"}),(0,s.jsx)(n.th,{children:"Strategy Focus"}),(0,s.jsx)(n.th,{children:"Key Resources"}),(0,s.jsx)(n.th,{children:"Team Coordination"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{children:"Food collection, basic exploration"}),(0,s.jsx)(n.td,{children:"Food, Linemate"}),(0,s.jsx)(n.td,{children:"Minimal"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"2-3"}),(0,s.jsx)(n.td,{children:"Map exploration, linemate collection"}),(0,s.jsx)(n.td,{children:"Linemate, Deraumere, Sibur"}),(0,s.jsx)(n.td,{children:"Broadcast positions"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"4-5"}),(0,s.jsx)(n.td,{children:"Group formation, targeted resource gathering"}),(0,s.jsx)(n.td,{children:"Phiras, Mendiane"}),(0,s.jsx)(n.td,{children:"Position coordination"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"6-8"}),(0,s.jsx)(n.td,{children:"Complex ritual planning, efficient resource sharing"}),(0,s.jsx)(n.td,{children:"Thystame"}),(0,s.jsx)(n.td,{children:"Full coordination"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"state-machine-implementation",children:"State Machine Implementation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class StateMachine:\n    def __init__(self):\n        self.states = {\n            "Explore": ExploreState(),\n            "Gather": GatherState(),\n            "Incantation": IncantationState(),\n            "Survival": SurvivalState(),\n            "Reproduction": ReproductionState(),\n            "Assist": AssistState()\n        }\n        self.current_state = "Explore"\n        \n    async def update(self, agent):\n        """Execute current state and check transitions"""\n        # Get current state\n        state = self.states[self.current_state]\n        \n        # Execute state action\n        result = await state.execute(agent)\n        \n        # Check for state transitions\n        next_state = state.check_transitions(agent, result)\n        if next_state != self.current_state:\n            await self.transition_to(next_state, agent)\n            \n        return result\n        \n    async def transition_to(self, new_state, agent):\n        """Handle state transition"""\n        old_state = self.states[self.current_state]\n        new_state_obj = self.states[new_state]\n        \n        # Exit current state\n        await old_state.exit(agent)\n        \n        # Update state\n        self.current_state = new_state\n        \n        # Enter new state\n        await new_state_obj.enter(agent)\n'})}),"\n",(0,s.jsx)(n.h2,{id:"resource-requirements-by-level",children:"Resource Requirements by Level"}),"\n",(0,s.jsx)(n.p,{children:"The AI manages resources based on the level requirements:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"# Level 1\u21922: 1 player, 1 linemate\n# Level 2\u21923: 2 players, 1 linemate, 1 deraumere, 1 sibur\n# Level 3\u21924: 2 players, 2 linemate, 0 deraumere, 1 sibur, 2 phiras\n# Level 4\u21925: 4 players, 1 linemate, 1 deraumere, 2 sibur, 1 phiras\n# Level 5\u21926: 4 players, 1 linemate, 2 deraumere, 1 sibur, 3 phiras\n# Level 6\u21927: 6 players, 1 linemate, 2 deraumere, 3 sibur, 0 phiras, 1 thystame\n# Level 7\u21928: 6 players, 2 linemate, 2 deraumere, 2 sibur, 2 phiras, 2 thystame\n"})}),"\n",(0,s.jsx)(n.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,s.jsx)(n.p,{children:"The AI implementation includes several optimizations:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Command Batching"}),": Grouping commands to reduce network overhead"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Perception Caching"}),": Storing and updating world state to minimize redundant lookups"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Parallel Processing"}),": Using asyncio for non-blocking operations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Memory Management"}),": Efficient data structures for world representation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Adaptive Timeout Handling"}),": Dynamic timeout adjustments based on server response times"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.p,{children:["This documentation provides a comprehensive overview of the AI client architecture. For implementation details, refer to the code in the ",(0,s.jsx)(n.code,{children:"src/AI/"})," directory."]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);