"use strict";(self.webpackChunkdocs_docusaurus=self.webpackChunkdocs_docusaurus||[]).push([[6192],{9347:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>m,frontMatter:()=>l,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"server/server-overview","title":"Server Architecture and Implementation","description":"Overview","source":"@site/docs/server/server-overview.md","sourceDirName":"server","slug":"/server/server-overview","permalink":"/Zappy/en/docs/server/server-overview","draft":false,"unlisted":false,"editUrl":"https://github.com/Epitech/Zappy/tree/main/docs/docusaurus/docs/server/server-overview.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Development Guide","permalink":"/Zappy/en/docs/development-guide"},"next":{"title":"Graphical Interface Architecture","permalink":"/Zappy/en/docs/gui/gui-overview"}}');var r=t(4848),a=t(8453);const l={sidebar_position:1},s="Server Architecture and Implementation",c={},o=[{value:"Overview",id:"overview",level:2},{value:"Core Architecture",id:"core-architecture",level:2},{value:"Main Server Structure",id:"main-server-structure",level:3},{value:"Client Management",id:"client-management",level:2},{value:"Client Types and States",id:"client-types-and-states",level:3},{value:"Connection Lifecycle",id:"connection-lifecycle",level:3},{value:"Command Processing System",id:"command-processing-system",level:2},{value:"Command Structure",id:"command-structure",level:3},{value:"Command Table",id:"command-table",level:3},{value:"Command Execution Pipeline",id:"command-execution-pipeline",level:3},{value:"Map System",id:"map-system",level:2},{value:"Tile Structure",id:"tile-structure",level:3},{value:"World Generation",id:"world-generation",level:3},{value:"Player Management",id:"player-management",level:2},{value:"Player Structure",id:"player-structure",level:3},{value:"Player Lifecycle",id:"player-lifecycle",level:3},{value:"Incantation System",id:"incantation-system",level:2},{value:"Level Requirements",id:"level-requirements",level:3},{value:"Time Management",id:"time-management",level:2},{value:"Network I/O System",id:"network-io-system",level:2},{value:"Resource Optimization",id:"resource-optimization",level:2},{value:"Memory Management",id:"memory-management",level:3},{value:"Performance Monitoring",id:"performance-monitoring",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"server-architecture-and-implementation",children:"Server Architecture and Implementation"})}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(n.p,{children:"The Zappy server is the central component of the system, developed in C for optimal performance. It manages the game state, client connections, and enforces all game rules. This document provides a technical exploration of the server's implementation."}),"\n",(0,r.jsx)(n.h2,{id:"core-architecture",children:"Core Architecture"}),"\n",(0,r.jsx)(n.h3,{id:"main-server-structure",children:"Main Server Structure"}),"\n",(0,r.jsx)(n.p,{children:"The server's core structure maintains the essential state and systems:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"typedef struct server_s {\n    int nfds;                           // Number of file descriptors\n    int server_fd;                      // Main server socket\n    struct sockaddr_in address;         // Server address\n    \n    // Management systems\n    poll_manager_t *poll_manager;       // Polling system for network I/O\n    time_manager_t *time_manager;       // Game time management\n    \n    // Game state\n    map_t *map;                         // Game world grid\n    team_manager_t *team_manager;       // Team information\n    client_manager_t *client_manager;   // Client connections\n    command_queue_t *command_queue;     // Pending commands\n    \n    // Configuration\n    server_config_t config;             // Server parameters\n    bool running;                       // Server status flag\n} server_t;\n"})}),"\n",(0,r.jsx)(n.h2,{id:"client-management",children:"Client Management"}),"\n",(0,r.jsx)(n.h3,{id:"client-types-and-states",children:"Client Types and States"}),"\n",(0,r.jsx)(n.p,{children:"The server distinguishes between two client types:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"enum client_type_e {\n    GRAPHICAL,                         // GUI observer client\n    AI                                 // Player AI client\n};\n\nenum client_state_e {\n    CONNECTED,                         // Initial connection state\n    AUTHENTICATED,                     // Valid team selected\n    ACTIVE,                            // Fully active in game\n    DISCONNECTING                      // In process of disconnection\n};\n\ntypedef struct client_s {\n    int socket_fd;                     // Client socket descriptor\n    enum client_type_e type;           // Client type\n    enum client_state_e state;         // Current state\n    \n    // Communication buffers\n    char read_buffer[BUFFER_SIZE];     // Input buffer\n    char write_buffer[BUFFER_SIZE];    // Output buffer\n    int read_pos;                      // Current read position\n    int write_pos;                     // Current write position\n    \n    // AI-specific data\n    player_t *player;                  // Player entity (NULL for GUI)\n    team_t *team;                      // Team affiliation\n    command_t *current_command;        // Currently executing command\n    bool command_in_progress;          // Command execution flag\n    uint64_t command_end_time;         // Command completion time\n    \n    // Queue management\n    list_t *command_queue;             // Pending commands\n} client_t;\n"})}),"\n",(0,r.jsx)(n.h3,{id:"connection-lifecycle",children:"Connection Lifecycle"}),"\n",(0,r.jsx)(n.p,{children:"The server implements a sophisticated connection state machine:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'// Connection handling\nvoid handle_new_connection(server_t *server) {\n    struct sockaddr_in client_addr;\n    socklen_t addrlen = sizeof(client_addr);\n    \n    // Accept new connection\n    int client_fd = accept(server->server_fd, \n                          (struct sockaddr *)&client_addr, \n                          &addrlen);\n    \n    if (client_fd < 0) {\n        log_error("Failed to accept connection");\n        return;\n    }\n    \n    // Configure as non-blocking\n    set_nonblocking(client_fd);\n    \n    // Initialize client structure\n    client_t *client = create_client(client_fd);\n    \n    // Add to polling system\n    add_client_to_poll(server->poll_manager, client);\n    \n    // Send welcome message\n    if (send_to_client(client, "WELCOME\\n") < 0) {\n        close_client_connection(server, client);\n        return;\n    }\n    \n    log_info("New client connected from %s:%d", \n             inet_ntoa(client_addr.sin_addr), \n             ntohs(client_addr.sin_port));\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"command-processing-system",children:"Command Processing System"}),"\n",(0,r.jsx)(n.h3,{id:"command-structure",children:"Command Structure"}),"\n",(0,r.jsx)(n.p,{children:"Commands are represented as structured objects with execution parameters:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"typedef struct command_s {\n    command_type_t type;               // Command identifier\n    char *raw_text;                    // Original command text\n    void *params;                      // Command-specific parameters\n    uint64_t execution_time;           // Required execution time in ticks\n    uint64_t start_time;               // When command began executing\n    bool is_executing;                 // Execution state flag\n    command_result_t (*execute)(struct command_s*, player_t*); // Execution function\n    void (*free_params)(void*);        // Parameter cleanup function\n} command_t;\n"})}),"\n",(0,r.jsx)(n.h3,{id:"command-table",children:"Command Table"}),"\n",(0,r.jsx)(n.p,{children:"The server uses a dispatch table to map commands to handlers:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Command"}),(0,r.jsx)(n.th,{children:"Execution Time (ticks)"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Forward"})}),(0,r.jsx)(n.td,{children:"7"}),(0,r.jsx)(n.td,{children:"Move player forward one tile"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Right"})}),(0,r.jsx)(n.td,{children:"7"}),(0,r.jsx)(n.td,{children:"Turn player right (90\xb0)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Left"})}),(0,r.jsx)(n.td,{children:"7"}),(0,r.jsx)(n.td,{children:"Turn player left (90\xb0)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Look"})}),(0,r.jsx)(n.td,{children:"7"}),(0,r.jsx)(n.td,{children:"Observe surrounding tiles"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Inventory"})}),(0,r.jsx)(n.td,{children:"1"}),(0,r.jsx)(n.td,{children:"Check player's inventory"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Broadcast"})}),(0,r.jsx)(n.td,{children:"7"}),(0,r.jsx)(n.td,{children:"Send message to all players"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Connect_nbr"})}),(0,r.jsx)(n.td,{children:"0"}),(0,r.jsx)(n.td,{children:"Get available team slots"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Fork"})}),(0,r.jsx)(n.td,{children:"42"}),(0,r.jsx)(n.td,{children:"Create new player egg"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Eject"})}),(0,r.jsx)(n.td,{children:"7"}),(0,r.jsx)(n.td,{children:"Eject players from current tile"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Take"})}),(0,r.jsx)(n.td,{children:"7"}),(0,r.jsx)(n.td,{children:"Take object from tile"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Set"})}),(0,r.jsx)(n.td,{children:"7"}),(0,r.jsx)(n.td,{children:"Place object on tile"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Incantation"})}),(0,r.jsx)(n.td,{children:"Variable"}),(0,r.jsx)(n.td,{children:"Perform level-up ritual"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"command-execution-pipeline",children:"Command Execution Pipeline"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"// Command execution flow\nvoid process_commands(server_t *server) {\n    uint64_t current_tick = server->time_manager->current_tick;\n    \n    // Process all clients\n    for (int i = 0; i < server->client_manager->count; i++) {\n        client_t *client = server->client_manager->clients[i];\n        \n        // Skip non-AI clients or inactive ones\n        if (client->type != AI || client->state != ACTIVE || !client->player) {\n            continue;\n        }\n        \n        // Check for command in progress\n        if (client->command_in_progress) {\n            if (current_tick >= client->command_end_time) {\n                // Command completed, execute and send result\n                command_result_t result = client->current_command->execute(\n                    client->current_command, client->player);\n                \n                send_command_result(client, result);\n                \n                // Clean up command\n                free_command(client->current_command);\n                client->current_command = NULL;\n                client->command_in_progress = false;\n            }\n        } \n        // Start next command if available\n        else if (!list_is_empty(client->command_queue)) {\n            client->current_command = list_pop_front(client->command_queue);\n            client->command_in_progress = true;\n            client->command_end_time = current_tick + \n                                     client->current_command->execution_time;\n            \n            // Special handling for immediate commands\n            if (client->current_command->execution_time == 0) {\n                command_result_t result = client->current_command->execute(\n                    client->current_command, client->player);\n                \n                send_command_result(client, result);\n                \n                // Clean up command\n                free_command(client->current_command);\n                client->current_command = NULL;\n                client->command_in_progress = false;\n            }\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"map-system",children:"Map System"}),"\n",(0,r.jsx)(n.h3,{id:"tile-structure",children:"Tile Structure"}),"\n",(0,r.jsx)(n.p,{children:"Each map tile contains resource quantities and entity references:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"typedef struct tile_s {\n    // Resource quantities\n    int food;                          // Food units\n    int linemate;                      // Level 1 stone\n    int deraumere;                     // Level 2 crystal\n    int sibur;                         // Level 3 mineral\n    int mendiane;                      // Level 4 gem\n    int phiras;                        // Level 5 stone\n    int thystame;                      // Level 6 crystal\n    \n    // Entities on tile\n    list_t *players;                   // Players on this tile\n    list_t *eggs;                      // Eggs on this tile\n    \n    // Tile state\n    bool incantation_active;           // Active ritual flag\n    uint64_t last_resource_update;     // Resource generation timestamp\n} tile_t;\n"})}),"\n",(0,r.jsx)(n.h3,{id:"world-generation",children:"World Generation"}),"\n",(0,r.jsx)(n.p,{children:"The map is generated with configurable parameters:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"map_t *create_map(int width, int height, resource_config_t *config) {\n    map_t *map = zappy_malloc(sizeof(map_t));\n    map->width = width;\n    map->height = height;\n    \n    // Allocate tile grid\n    map->tiles = zappy_malloc(sizeof(tile_t*) * height);\n    for (int y = 0; y < height; y++) {\n        map->tiles[y] = zappy_malloc(sizeof(tile_t) * width);\n        \n        // Initialize each tile\n        for (int x = 0; x < width; x++) {\n            tile_t *tile = &map->tiles[y][x];\n            memset(tile, 0, sizeof(tile_t));\n            \n            tile->players = list_create();\n            tile->eggs = list_create();\n            \n            // Initial resources based on probability\n            if (rand() % 100 < config->food_probability) {\n                tile->food = rand() % config->max_food_per_tile + 1;\n            }\n            \n            // Initialize other resources with decreasing probability\n            // ...\n        }\n    }\n    \n    return map;\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"player-management",children:"Player Management"}),"\n",(0,r.jsx)(n.h3,{id:"player-structure",children:"Player Structure"}),"\n",(0,r.jsx)(n.p,{children:"Players have extensive state information:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"typedef struct player_s {\n    int id;                            // Unique ID\n    int x;                             // X position\n    int y;                             // Y position\n    direction_t direction;             // Facing direction (N,E,S,W)\n    int level;                         // Current level (1-8)\n    \n    // Inventory\n    inventory_t inventory;             // Resource storage\n    \n    // Game state\n    team_t *team;                      // Team affiliation\n    bool alive;                        // Survival status\n    uint64_t last_food_time;           // Last food consumption time\n    uint64_t next_food_time;           // Next food consumption time\n    \n    // References\n    client_t *client;                  // Associated client\n} player_t;\n\ntypedef struct inventory_s {\n    int food;                          // Food units\n    int linemate;                      // Level 1 stone\n    int deraumere;                     // Level 2 crystal\n    int sibur;                         // Level 3 mineral\n    int mendiane;                      // Level 4 gem\n    int phiras;                        // Level 5 stone\n    int thystame;                      // Level 6 crystal\n} inventory_t;\n"})}),"\n",(0,r.jsx)(n.h3,{id:"player-lifecycle",children:"Player Lifecycle"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'// Player creation\nplayer_t *create_player(server_t *server, team_t *team) {\n    player_t *player = zappy_malloc(sizeof(player_t));\n    \n    // Initialize with defaults\n    player->id = server->next_player_id++;\n    player->level = 1;\n    player->alive = true;\n    player->team = team;\n    \n    // Random starting position\n    player->x = rand() % server->map->width;\n    player->y = rand() % server->map->height;\n    \n    // Random starting direction\n    player->direction = rand() % 4;\n    \n    // Initial inventory\n    memset(&player->inventory, 0, sizeof(inventory_t));\n    player->inventory.food = 10;  // Starting food\n    \n    // Set food timers\n    player->last_food_time = server->time_manager->current_tick;\n    player->next_food_time = player->last_food_time + FOOD_CONSUMPTION_RATE;\n    \n    // Add to map tile\n    add_player_to_tile(server->map, player);\n    \n    log_info("Created player %d in team %s at position (%d,%d)",\n             player->id, team->name, player->x, player->y);\n             \n    return player;\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"incantation-system",children:"Incantation System"}),"\n",(0,r.jsx)(n.h3,{id:"level-requirements",children:"Level Requirements"}),"\n",(0,r.jsx)(n.p,{children:"The incantation system enforces specific requirements for each level upgrade:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"// Level requirements verification\nbool check_incantation_requirements(map_t *map, player_t *player) {\n    tile_t *tile = &map->tiles[player->y][player->x];\n    int player_count = list_size(tile->players);\n    \n    // Requirements array indexed by target level (level-1)\n    static const struct {\n        int players;       // Required player count\n        int linemate;      // Required linemate\n        int deraumere;     // Required deraumere\n        int sibur;         // Required sibur\n        int mendiane;      // Required mendiane\n        int phiras;        // Required phiras\n        int thystame;      // Required thystame\n    } level_reqs[] = {\n        {1, 1, 0, 0, 0, 0, 0},  // Level 1->2\n        {2, 1, 1, 1, 0, 0, 0},  // Level 2->3\n        {2, 2, 0, 1, 0, 2, 0},  // Level 3->4\n        {4, 1, 1, 2, 0, 1, 0},  // Level 4->5\n        {4, 1, 2, 1, 3, 0, 0},  // Level 5->6\n        {6, 1, 2, 3, 0, 1, 0},  // Level 6->7\n        {6, 2, 2, 2, 2, 2, 1}   // Level 7->8\n    };\n    \n    // Check current level is valid for advancement\n    if (player->level <= 0 || player->level >= 8) {\n        return false;\n    }\n    \n    // Get requirements for next level\n    const int req_idx = player->level - 1;\n    \n    // Check player count\n    if (player_count < level_reqs[req_idx].players) {\n        return false;\n    }\n    \n    // Check minimum player level\n    for (node_t *node = tile->players->head; node != NULL; node = node->next) {\n        player_t *p = (player_t *)node->data;\n        if (p->level < player->level) {\n            return false;  // All players must be at least this level\n        }\n    }\n    \n    // Check resources on tile\n    if (tile->linemate < level_reqs[req_idx].linemate ||\n        tile->deraumere < level_reqs[req_idx].deraumere ||\n        tile->sibur < level_reqs[req_idx].sibur ||\n        tile->mendiane < level_reqs[req_idx].mendiane ||\n        tile->phiras < level_reqs[req_idx].phiras ||\n        tile->thystame < level_reqs[req_idx].thystame) {\n        return false;\n    }\n    \n    return true;\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"time-management",children:"Time Management"}),"\n",(0,r.jsx)(n.p,{children:"The server implements a sophisticated time management system:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"typedef struct time_manager_s {\n    int frequency;                      // Ticks per second\n    double tick_duration_ms;            // Milliseconds per tick\n    uint64_t current_tick;              // Current game time\n    struct timeval last_update_time;    // Last update time\n} time_manager_t;\n\nvoid update_time(server_t *server) {\n    time_manager_t *tm = server->time_manager;\n    struct timeval current_time;\n    gettimeofday(&current_time, NULL);\n    \n    // Calculate elapsed time in milliseconds\n    long elapsed_ms = \n        (current_time.tv_sec - tm->last_update_time.tv_sec) * 1000 +\n        (current_time.tv_usec - tm->last_update_time.tv_usec) / 1000;\n    \n    // Calculate elapsed ticks\n    uint64_t elapsed_ticks = elapsed_ms / tm->tick_duration_ms;\n    \n    if (elapsed_ticks > 0) {\n        tm->current_tick += elapsed_ticks;\n        tm->last_update_time = current_time;\n        \n        // Process time-based events like food consumption\n        process_time_events(server, elapsed_ticks);\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"network-io-system",children:"Network I/O System"}),"\n",(0,r.jsx)(n.p,{children:"The server uses non-blocking I/O with a polling mechanism:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'typedef struct poll_manager_s {\n    struct pollfd *pollfds;            // Array of poll structures\n    int nfds;                           // Number of file descriptors\n    int capacity;                       // Allocated capacity\n} poll_manager_t;\n\nvoid process_network_events(server_t *server) {\n    poll_manager_t *pm = server->poll_manager;\n    \n    // Wait for network events (timeout = 10ms for responsiveness)\n    int activity = poll(pm->pollfds, pm->nfds, 10);\n    \n    if (activity < 0) {\n        if (errno != EINTR) {\n            log_error("Poll failed: %s", strerror(errno));\n        }\n        return;\n    }\n    \n    // Check server socket for new connections\n    if (pm->pollfds[0].revents & POLLIN) {\n        handle_new_connection(server);\n    }\n    \n    // Process client sockets\n    for (int i = 1; i < pm->nfds; i++) {\n        // Handle readable sockets (data available)\n        if (pm->pollfds[i].revents & POLLIN) {\n            process_client_input(server, i);\n        }\n        \n        // Handle writable sockets (can send data)\n        if (pm->pollfds[i].revents & POLLOUT) {\n            process_client_output(server, i);\n        }\n        \n        // Handle disconnect/error events\n        if (pm->pollfds[i].revents & (POLLHUP | POLLERR | POLLNVAL)) {\n            handle_client_disconnect(server, i);\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"resource-optimization",children:"Resource Optimization"}),"\n",(0,r.jsx)(n.p,{children:"The server includes several optimizations for resource efficiency:"}),"\n",(0,r.jsx)(n.h3,{id:"memory-management",children:"Memory Management"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'// Custom memory allocator with tracking\nvoid *zappy_tracked_malloc(size_t size, const char *file, int line) {\n    void *ptr = malloc(size);\n    if (!ptr) {\n        log_critical("Memory allocation failed at %s:%d", file, line);\n        exit(EXIT_FAILURE);\n    }\n    \n    // Track allocation for leak detection\n    #ifdef MEMORY_DEBUG\n    track_allocation(ptr, size, file, line);\n    #endif\n    \n    return ptr;\n}\n\n// Memory leak detection\nvoid check_memory_leaks(void) {\n    #ifdef MEMORY_DEBUG\n    allocation_stats_t stats = get_allocation_stats();\n    \n    if (stats.active_allocations > 0) {\n        log_warning("Memory leak detected: %d allocations, %zu bytes not freed",\n                   stats.active_allocations, stats.active_bytes);\n        \n        // Print detailed leak information\n        print_memory_leaks();\n    }\n    #endif\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"performance-monitoring",children:"Performance Monitoring"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"typedef struct server_stats_s {\n    // Network stats\n    uint64_t bytes_received;\n    uint64_t bytes_sent;\n    uint64_t connections_accepted;\n    uint64_t connections_closed;\n    \n    // Command stats\n    uint64_t commands_processed;\n    uint64_t commands_successful;\n    uint64_t commands_failed;\n    \n    // Performance stats\n    double avg_tick_time_ms;\n    double peak_tick_time_ms;\n    uint64_t tick_samples;\n    \n    // World stats\n    uint64_t resources_generated;\n    uint64_t resources_consumed;\n    uint64_t players_died;\n    uint64_t eggs_laid;\n    uint64_t eggs_hatched;\n    uint64_t incantations_started;\n    uint64_t incantations_completed;\n} server_stats_t;\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.p,{children:"This document provides a technical overview of the Zappy server's architecture and implementation. For protocol details, refer to the protocol documentation."})]})}function m(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);